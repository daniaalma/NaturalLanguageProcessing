# Homework 2 - No Silver Bullet
## TEAM: Dania Elmadhun and Preethi Vijai LIlly

1. **Define the term _essential difficulties_ as it is used by Brooks. Provide background and context with your answer and at least one example of an essential difficulty.**

**Team Answer:**
Brooks defines essential difficulties as complications that are intrinsically ingrained within software technology. Essential difficulties are associated with the complex software design.The essential properties where these difficulties stem from are properties software technology must have in order to be software technology. This is used to define the reasons why a “silver bullet” is as mythical as the background it is derived from. An essential difficulty that resonates most with past professional experience is from conformity. Software can become increasingly difficult because it is designed and created by different people. Inspired by Brook’s love of analogies: this can be thought of similar to 10 people creating a quilt, each using different fabric, thread, stuffing and stitching techniques. At the end of the day, the quilt may adhere to the final acceptance criteria but doesn’t have an obvious start or end and is hard to look at. From personal experience, this essential difficulty is one that could never be solved with a silver bullet, so long as humans differ in thought processes and software continues to be developed by humans.

An instance of an essential difficulty could be the complexity involved before developing any platform, say for healthcare domain. There would be multiple technologies in the platform including provisions required for support to legacy tech. The upstream/downstream data flow and privacy requisites and designing an architecture for a complicated platform.


1. **Define the term _accidental difficulties_ as it is used by Brooks. Provide background and context with your answer and at least one example of an accidental difficulty.**

**Team Answer:**
Accidental difficulties differ from essential difficulties because they come from properties that aren’t woven into the foundation of software technology. These are difficulties that have the potential of being solved. Accidental difficulties that arise from design processes of programming and result in knotted connections that break at the slightest change have been solved with the introduction of object-oriented programming. This solution does not fix the essential difficult, which is the complexity of the design itself that has not been made easier with the introduction of abstract programming. 
A bug introduced into a software platform in a later stage of maintenance, which creates performance issue, is an accidental difficulty. Unlike essential difficulty this can be solved.

1. **List and briefly describe the four essential difficulties of developing software systems that Brooks identifies. Provide additional examples of each type of the four essential difficulties.**

**Team Answer:**
Brooks references 4 properties that represent the essential difficulties of software systems; complexity, conformity, changeability and invisibility. Complexity is the essential difficulty with how complicated the many different connected parts of a software can become. Conformity is the compliance with other software systems, hardware and API’s that further increase the complexity of the system. Invisibility is the lack of visualization that is in software systems which can muddy the vision between designers, managers and nontechnical members of the team. 

Complexity in software systems is an essential difficulty which is the basis for many of the essential difficulties and their examples below. An example of this is the complexity with communicating and lack of understanding of the software system. Because no two parts in the software system are the same, communicating features, updates or processes can become too complex with many important details being left out.

Conformity in software systems is an essential property that creates difficulty. An example of this is it’s need to be used in conjunction with other programs which have been built in such a way that force additional requirements and complications within the code to work together “seamlessly”. These complications are an essential part of the software system and cannot be changed. The software should be designed to conform with the existing hardware.

Changeability in software systems is the force of change that has become expected. This is an essential difficulty as the change is necessary to keep up with the changes of the hardware and other programs running synchronously with our software system. Something working yesterday may no longer work today, where updates in other systems running in conjunction with the software system can break processes running which may require housekeeping to change and conform to updates made. For example, some systems may “sunset” certain features or API’s that the current system is using and the software designer must change their own system to conform. 

Invisibility is an essential difficulty that can create issues with communicating the vision of a software system to other members of the team, whether technical or nontechnical. This difficulty could be the roadblocks created for software designers to find the correct solution to issues they face on a daily basis, which stems from the lack of visualizing the system they are working with and not understanding the need to fix the problem. This could potentially make a software design very complex when there was a simple solution all along. Any attempt at creating a visual pattern for an underlying software resulted in non-planar and non-hierarchical representations which was difficult to interpret.

1. **Define what Brooks means by a _silver bullet_ and reconstruct his argument as to why he believes there is no silver bullet for software engineering.

**Team Answer:**
The silver bullet analogy stems from the folklore tales of mythical creatures like werewolves and the silver weapons that are the only defense we have to defeat them. Similar to waving a magic wand, using a silver bullet will lay the beast to rest. This analogy is well fit to the situation as software systems can behave similar to a werewolf. The non-technical manager is transformed into the townspeople of the analogy, who initially sees the werewolf as a kind person not to be feared until it is suddenly transformed into a beast wreaking havoc on the town. This havoc in real software systems is actually a black hole of money loss, developers time and missed deadlines. The townspeople want a quick solution, find the silver bullet that can solve this issue. However, the silver bullet does not currently exist. 
Brooks goes on to describe the reasons why the silver bullet for software systems is not likely possible, as the difficulties are foundational properties of software. Accidental difficulties, as described above, have the potential to be solved. However the properties of software engineering that are the cause of these issues cannot be solved as they are properties of the software systems that make the software system what it is.  

1. **In lecture, software engineering's relationship to computer science was described by analogy by discussing the differences between a chemist (chemistry) and a chemical  engineer (chemical engineering). Define software engineering and its relationship to computer science; make use of the chemist vs. chemical engineer analogy when answering this question.**

**Team Answer:**
Software engineering is the practice of applying the theoretical discoveries of computer science. Utilizing algorithms and patterns and putting them into practice is software engineering, similar to the relationship between a chemist and  chemical engineering. Chemical engineers take the key principles of chemistry and apply them to solve real-world problems by providing the engineer with a “toolkit” to get to those solutions. Similarly, software engineering applies all the concepts of computer science.

1. **In the lecture, we discussed the importance of the following concepts to software engineers: abstractions, conversations, specification, translation, and iteration. Define each of these concepts as they are related to software engineering and discuss their importance.**

**Team Answer:**
Abstractions: Abstraction works by establishing simplicity by which a person interacts with a system and suppressing the complex details below the current level. For example, if a person has to send an email and start the process from scratch, they will have to design the networks, fibre optics and all the underlying interfaces used to transmit data. Instead, by abstraction, we present the programmer with a virtual data channel which makes the task manageable. Abstraction refers to the representation of essential features while masking the complexities and background details of the feature.These are necessary to improve the user experience for any feature.

Conversations: Software engineering is more about the communication and feedback. The more information is provided, more changes can be adapted iteratively. This is essential to build software systems which are more aligned with the requirements.

Specification: Software engineers are required to specify everything they build. These include the business requirement document, design document, code, test plans and all the specifications involved in a development cycle. This is essential to understand/debug the platform after deployment.

Translation: Software engineering should also be able to translate from one interface to another, from one abstraction to another and from one specification to another. Hardware is ever evolving and software engineering should be flexible enough to translate from one device specification to another.

Iteration: Software development is done in an iterative manner. The techniques have evolved from a waterfall model to a continuous delivery approach such as a scrum/agile methodology. This leads to a better customer satisfaction, as the customer can download patches of the iterative delivery method rather than having to wait for a long time, like in the case of waterfall approach

